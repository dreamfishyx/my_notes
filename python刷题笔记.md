##### 细节性问题

1. 在 Python 中，<font color=red>在递归函数中使用可变对象（如列表、字典）作为默认参数需要格外注意</font>。这是因为默认参数的值在函数定义时仅初始化一次，而不是每次调用函数时重新创建。递归调用中如果不显式传递参数，所有递归层会共享同一个默认参数对象，导致数据污染。

   ```python
   def insert(ele,lst=[]):
       lst.append(ele)
       return lst
   
   print(insert(1))    # [1]
   print(insert(2))    # [1, 2]
   ```

2. pyhton 的参数传递机制有些复杂，对于可变对象，传递的是引用，此时修改参数会影响原变量。而对于不可变参数，其实就是一个新变量(复制)。而在 java 则参数是原变量的复制体。

3. 不要在 for 循环中修改被遍历的可变对象，其实根据上一条，可以很容易理解

   ```python
   # 一直遍历，无法停止
   list = [1, 2, 3, 4, 5]
   for i in list:
       print(i)
       list.append(i)
   ```







##### SortedList

1. SortedList 是 Python 中 sortedcontainers 模块提供的一个数据结构，它是一个有序的列表，支持高效的插入、删除和查找操作。它的设计目标是提供类似于 Python 内置 list 的接口，同时保持元素的有序性。

2. SortedList 的底层实现基于以下几个关键点：

   - 分段有序数组：SortedList 将数据分成多个小的有序数组（称为段），每个段的大小适中，便于快速查找和插入。
   - 二分查找：在插入或查找元素时，使用二分查找算法快速定位元素应该插入的位置。
   - 动态调整：当某个段变得过大时，SortedList 会自动将其拆分成更小的段，以保持操作的效率。

4. 在普通的动态数组中，插入一个元素时，可能需要移动大量的元素。在 SortedList 中，数据被分成多个段，每个段的大小是 O(√n)。插入新元素时，只需要在某个段内部移动元素，移动的次数最多是 O(√n)。

5. SortedList 默认按照元素的自然顺序进行排序。对于数字类型，按升序排列；对于字符串类型，按字典序排列。如果需要自定义排序规则，可以通过 `key` 参数指定一个处理函数，按照函数返回结果排序。

   ```bash
   # 按绝对值排序
   sl = SortedList([-3, 1, -4, 2], key=abs)
   print(sl)  # 输出: SortedList([1, 2, -3, -4])
   ```

6. 使用方法:

   1. `add`插入
   2. `discard`删除
   3. `irange`范围查询
   4. `update`合并





##### defaultdict

1. defaultdict 是 Python 标准库 collections 模块中的一个类，它是 dict 的一个子类。它的特点是：

   1. 当访问一个不存在的键时，defaultdict 会自动调用指定的工厂函数，生成一个默认值，并将该键值对添加到字典中。
   2. 这样可以避免在访问不存在的键时抛出 KeyError 异常。

2. 具体使用:

   ```python
   map = defaultdict(SortedList)
   map[apple].add(20)
   ```

   



##### 优先队列

1. 优先队列(Priority Queue)和堆(Heap)不是同一个东西，但堆是实现优先队列的高效数据结构。优先队列是一种抽象数据类型，支持插入元素和按优先级取出元素，而堆是实现优先队列的一种方式。优先队列可以用堆、有序数组或其他结构实现，但堆是最常用的，因为它效率高。

2. Python 通过 `heapq` 模块提供堆操作，但需注意:默认是最小堆，且底层用列表、模拟堆结构，通过索引关系维护父子节点。

3. 常用方法:

   1. `heapify(x)`:创建堆，将列表 x 原地转换为堆，会修改 x 。<font color=red>x 还是普通 list 类型，不具备堆的各种方法。</font>
   2. `heappush(heap, item)`:插入元素 item 并维护堆结构。
   3. `heappop(heap)`:弹出堆顶元素。
   4. 查看堆顶元素:直接访问 `heap[0]`。
   5. `heapq.merge(*iterables)`:合并堆，合并多个有序迭代器，返回合并后的迭代器。
   6. `heapreplace(heap, item)`:替换堆顶元素,先弹出堆顶，再插入新元素(比 `heappop + heappush` 高效)。
   7. `heappushpop(heap, item)`:插入并弹出,先插入元素，再弹出堆顶(与 `heapreplace` 顺序相反)。

4. <font color=red>Python 的 `heapq` 仅支持最小堆，但可通过取负数模拟最大堆。</font>

5. 具体演示一下:

   ```python
   import heapq
   
   lst = [5, 4, 3, 2, 1]
   heapq.heapify(lst) 
   print(lst) # [1, 2, 3, 5, 4]
   heapq.heappush(lst, 0)
   print(lst) # [0, 2, 1, 5, 4, 3]
   print(heapq.heappop(lst)) # 0
   
   print(type(lst)) # <class 'list'>
   ```

   





##### python缓存

1. 在Python中，`@lru_cache`和`@cache`是用于缓存函数调用结果的装饰器，可显著优化递归等重复计算的性能。

2. `@lru_cache(maxsize=None)`通过LRU(最近最少使用)算法缓存函数结果,`maxsize=None`表示缓存无大小限制，所有结果均保留。避免重复计算。例如斐波那契递归中，`fib(n)`的结果会被缓存，后续相同参数的调用直接返回缓存值。

3. `@cache`( python 3.9+)等价于`@lru_cache(maxsize=None)`，是无限制缓存的语法糖。

4. 使用示例:

   ```python
   from functools import lru_cache, cache
   
   # 使用 lru_cache
   @lru_cache(maxsize=None)
   def fib_lru(n):
       if n <= 1:
           return n
       return fib_lru(n-1) + fib_lru(n-2)
   
   # 使用 cache
   @cache
   def fib_cache(n):
       if n <= 1:
           return n
       return fib_cache(n-1) + fib_cache(n-2)
   ```

5. 二者均用于缓存函数结果，优化性能。但`@lru_cache`需指定`maxsize`，灵活性更高。`@cache`是`@lru_cache(maxsize=None)`的简化版，仅适用于Python 3.9及以上版本。

> 若是参数中含有可变类型，以下装饰器如何判断参数是否一致呢？在没有完全理解了解慎用！！！
>
> - 在 Python 中，`@cache` 或 `@lru_cache` 装饰器通过将函数参数转换为可哈希的键来判断调用是否相同。
> - 装饰器会将所有位置参数`*args`和关键字参数`**kwargs`组合成一个哈希键，作为缓存字典的键。
> - 可变对象(如列表、字典)本身不可哈希，直接作为参数会报错，此时需要转换为不可变类型，其中细节部分都需要去尝试！！！

| 问                   | 答                                   |
| -------------------- | ------------------------------------ |
| 可变对象存储方式     | 存储为地址引用，内容可变但地址不变。 |
| 列表转元组地址变化   | 地址会变，生成新对象。               |
| 元组哈希依据         | 基于内容，而非地址。                 |
| 可变对象不可哈希原因 | 内容可变会导致哈希不一致。           |





##### 判断质数

```python
def isPrime(n):
    if n <= 2: # 1和2都是素数
        return False
    for i in range(2, n): # 判断是否可以被2~n-1整除
        if n % i == 0:
            return False
    return True
```

```python
from math import sqrt

def isPrime(n):
    if n <= 2: 
        return False
    for i in range(2, int(sqrt(n)) + 1 ):  # int(num**0.5) + 1
        if n % i == 0:
            return False
    return True
```
线性筛选:???





##### 公因数、公倍数

```python
# 最大公约数
def gcd(a, b):
    if a < b: # 保证a大于b
        a, b = b, a
    while b != 0: # 辗转相除法
        a, b = b, a % b
    return a
```

```python
def gcd(a, b):
    if a < b: # 保证a大于b
        a, b = b, a
    while b != 0: # 辗转相除法
        a, b = b, a % b
    return a

# 最小公倍数
def lcm(a, b):
    return a * b // gcd(a, b)
```









##### 贪心

1. 首先，贪心算法是在每一步选择当前看起来最优的解，希望这样能得到全局最优。但问题在于，并不是所有问题都适用，因为局部最优的累积不一定是全局最优。比如背包问题，如果是分数背包的话，贪心是有效的，但如果是0-1背包，贪心可能就不行，因为可能选了某个高价值但重量大的物品，导致后面装不下更多有价值的轻物品。
2. 何时使用贪心算法?

   1. **最优子结构**：问题的最优解包含子问题的最优解。
   2. **贪心选择性质**：每一步的局部最优选择能导向全局最优解，无需回溯。
   3. **无后效性**：当前决策不影响后续子问题的结构。

3. 如何验证贪心正确性？

   1. 数学证明：
      1. <font color=red>替换法：假设存在一个最优解，证明用贪心选择替换后仍最优。(反证法)</font>
      2. 归纳法：证明贪心选择在每一步均保持最优解的可能性。

   2. 反例测试：构造可能使贪心失效的案例（如非规范硬币找零、0-1背包问题）。

4. 正确运用贪心的技巧

   1. 问题分析：
      - 识别是否为经典贪心问题（任务调度、最小生成树、霍夫曼编码等）。
      - 检查是否满足最优子结构和贪心选择性质。
   2. 策略设计：
      - 按特定属性排序（如结束时间、权重密度等）。
      - 选择当前最优指标（最短路径、最大收益等）。
   3. 验证与调试：
      - 严格数学证明或反例验证。
      - 对比动态规划解法，判断是否贪心足够。

5. 经典应用场景

   - 分数背包：按价值密度排序，贪心有效。

   - 活动选择：按结束时间排序选最多活动。

   - Dijkstra算法：无负权边时，贪心选择最短路径。

   - Prim/Kruskal算法：构造最小生成树的贪心策略。







##### 动态规划

1. 何时使用动态规划？动态规划的核心在于 **状态设计** 与 **递推关系**,动态规划适用于满足以下两个关键条件的问题：

   1. **最优子结构**: 问题的最优解包含其子问题的最优解。例如，最短路径问题中，A→B→C的最短路径必然包含A→B的最短路径。

   1. **重叠子问题**: 子问题在求解过程中被重复计算多次。例如，斐波那契数列中，计算 `fib(5)` 需要多次计算 `fib(3)` 和 `fib(2)`。

2. 正确运用DP的技巧:

   1. 状态定义: 将问题转化为可递推的数学形式。

      - 背包问题: `dp[i][w]` 表示前 i 个物品在容量 w 下的最大价值。
      - 编辑距离: `dp[i][j]` 表示字符串 `A[0..i]` 和 `B[0..j]` 的最小编辑次数。

   2. 状态转移方程: 明确父问题与子问题的递推关系。

      - 斐波那契数列: `dp[i] = dp[i-1] + dp[i-2]`。

      - 最长公共子序列:

        ```python
        if A[i] == B[j]:
            dp[i][j] = dp[i-1][j-1] + 1
        else:
            dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        ```

   3. 初始化与边界条件: 明确最小子问题的解。

      - 网格路径: `dp[0][0] = grid[0][0]`(起点)。
      - 硬币找零: `dp[0] = 0`(总金额为0时不需要硬币)。

   4. 填表顺序: 确保子问题在父问题之前解决。

      - **自底向上(迭代)**: 按状态维度从小到大遍历（如二维表按行或列填充）。
      - **自顶向下(记忆化搜索)**: 通过递归+缓存(如Python的`lru_cache`)实现按需计算。

   5. 空间优化

      - **滚动数组**：压缩状态空间，例如将二维DP优化为一维数组(如背包问题的空间优化)。
      - **状态合并**：去除冗余维度(如斐波那契数列只需保留前两项)。

3. 如何保证子问题在父问题前被解决？

   - 自底向上方法:显式按顺序计算子问题

     - 在编辑距离问题中，按行或列填充二维表，确保 `dp[i][j]` 计算时，`dp[i-1][j]`、`dp[i][j-1]` 和 `dp[i-1][j-1]` 已计算。
     - 在背包问题中，外层循环遍历物品，内层循环遍历容量，保证每个容量状态按顺序更新。

   - 自顶向下方法:通过递归调用自动分解问题，配合缓存记录已解决的子问题。

     ```python
     from functools import lru_cache
     
     @lru_cache(maxsize=None)
     def fib(n):
         if n <= 1:
             return n
         return fib(n-1) + fib(n-2)
     ```

4. 验证与调试技巧:

   1. 手动模拟小例子: 例如，对于 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`（网格路径数），手动计算 `2x2` 网格验证结果是否为2。
   2. 打印DP表: 输出中间状态，观察是否符合预期。例如，检查硬币找零问题中 `dp` 数组的逐步填充过程。
   3. 对比暴力解: 对于小规模输入，对比DP解与暴力递归的结果是否一致。
   4. 数学归纳法: 假设子问题的解正确，证明父问题的解正确。例如，证明LCS的递推关系成立。

5. 典型应用场景:

   - **背包问题**: 0-1背包、完全背包、多重背包。

   - **序列问题**: 最长公共子序列 LCS、最长递增子序列 LIS。

   - **路径规划**: 网格最小路径和、编辑距离。

   - **资源分配**: 任务调度、矩阵链乘法。

6. 经典示例：硬币找零问题:给定硬币面额 `coins = [1, 2, 5]` 和总金额 `amount = 11`，求最少需要多少枚硬币。

   1. 状态定义: `dp[i]` 表示凑出金额 `i` 所需的最少硬币数。
   2. 状态转移: `dp[i] = min(dp[i - coin] + 1 for coin in coins if i >= coin)`。
   3. 初始化: `dp[0] = 0`，其余初始化为正无穷。
   4. 填表顺序: 从 `i=1` 到 `i=amount` 依次计算。
   5. 结果: `dp[11] = 3`(5+5+1)。
