#### 修改参数

1. 修改 redis 的配置一般而言是在 redis.conf 中配置。

2. 但是实际上我们可以通过命令实现:
   1. `config get`获取配置内容及其相关信息。
   
      ```bash
      127.0.0.1:6379> config get *
        1) "bgsave_cpulist"
        2) ""
        3) "hll-sparse-max-bytes"
        4) "3000"
        5) "bio_cpulist"
        6) ""
        7) "protected-mode"
        8) "no"
        9) "proc-title-template"
      ```
   
   2. `config set`允许在不重启 Redis 的情况下修改部分参数。<font color=red>使用 CONFIG SET 命令动态修改的配置参数在Redis 服务重启后会失效,若要永久生效请使用 CONFIG REWRITE 命令。 </font>
   
   3. `CONFIG REWRITE` 命令将当前配置写入 redis.conf 文件(需 Redis 有写入权限）
   
3. <font color=red>部分参数不可动态修改</font>：如 `port`、`dir`、`dbfilename` 等需直接修改配置文件并重启。





#### 持久化

##### 简介

1. [官方介绍](https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/):持久性指的是将数据写入持久存储，例如固态硬盘 SSD ，Redis 提供了一系列持久化选项:
   - RDB(Redis Database):RDB 持久化在指定的时间间隔内对您的数据集执行点时间快照。
   - AOF(Append Only File):AOF 持久化记录服务器接收到的每个写操作。这些操作可以在服务器启动时再次回放，重建原始数据集。命令使用与 Redis 协议相同的格式进行记录。
   - 无持久性：您可以完全禁用持久性,这有时用于 redis 仅用作缓存。
   - RDB + AOF：可以在同一实例中同时使用 AOF 和 RDB。
2. 为什么需要持久化?
   - 内存数据的脆弱性:Redis 数据默认存储在内存中，速度快但易失，进程终止或服务器宕机会导致所有数据丢失。例如电商秒杀活动中，若 Redis 缓存了库存信息但未持久化，服务器宕机后库存数据无法恢复，引发超卖问题。
   - 业务连续性要求:关键业务需保证数据可靠，即使故障也能快速恢复。例如用户支付成功后，订单状态若仅存于内存，支付凭证丢失将导致纠纷。
   - 容灾与备份:持久化数据可用于迁移、复制或灾难恢复，如硬盘损坏后从备份恢复。
3. 示意图:<br><img src="./assets/image-20250227160610453.png" alt="image-20250227160610453" style="zoom:75%;" />







##### RDB

1. RDB 持久性以指定的时间间隔执行数据集的时间点快照。其实现类似照片记录效果的方式，就是把某一时刻的数据和状态以文件的形式写到磁盘上，也就是快照。这样一来即使故障宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为RDB文件(dump.rdb)，其中，RDB就是Redis DataBase的缩写。

2. RDB是一种一锅端式的备份，Redis的数据都在内存中，保存备份时它执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘中，一锅端。<br><img src="./assets/image-20250227162643389.png" alt="image-20250227162643389" style="zoom:67%;" />

3. Redis 6 和 Redis 7 的区别:主要是在 redis.conf 中配置的定时快照的条件。

   1. Redis 6.0.16 及以前:存在<br><img src="./assets/image-20250227163125721.png" alt="image-20250227163125721" style="zoom:75%;" />

      > - 每隔 900s 内，存在 1 个 key 改变则写一份新的 rdb 文件。
      > - 每隔 300s 内，存在 10 个 key 改变则写一份新的 rdb 文件。
      > - 每隔 60s 内，存在 10000个 key 改变则写一份新的 rdb 文件。

   2. Redis 6.2 及以后:<br><img src="./assets/image-20250227163222634.png" alt="image-20250227163222634" style="zoom:75%;" />

      > - 每隔 3600s 内，存在 1 个 key 改变则写一份新的 rdb 文件。
      > - 每隔 300s 内，存在 100 个 key 改变则写一份新的 rdb 文件。
      > - 每隔 60s 内，存在 10000个 key 改变则写一份新的 rdb 文件。

4. 自动触发:

   1. 修改自动触发的条件: redis.conf 中的`save <seconds> <changes>`

   2. 修改 rdb 文件存储位置: redis.conf 中的`dir <dir_name>`

   3. 修改 rdb 文件名称: redis.conf 中的`dbfilename <file_name>`，<font color=red>一般在实际生产，文件名一般设置成 Redis 实例的端口号相关。</font>

   4. 不妨做一个测试，我们将配置文件修改成如下所示(提前备份配置文件):

      ```tex
      save 10 2
      
      dir /redis/bak
      
      dbfilename dump6379.rdb
      ```
      
      修改完配置之后重启 Redis。上述配置中，我们将自动触发的条件设置为每隔 10s 存在 2 个 key 改变则生成一份新的 rdb 文件。初始状态下，没有任何 rdb 文件存在。当我们在 10s 内连续插入两个 key 时，观察到存在 rdb 文件生成。
      
      我们在次向redis中插入两个 key ，但是中间等待 10 s，此时发现 rdb 文件大小无变化，此时数据并没有持久化到磁盘，此时若是 redis 宕机，数据就会丢失。<br><img src="./assets/image-20250227183850026.png" alt="image-20250227183850026" style="zoom:67%;" /><br><img src="./assets/image-20250227184558819.png" alt="image-20250227184558819" style="zoom:67%;" />
      

5. 手动触发:Redis提供了两个命令来生成 RDB 文件，分别是 `save` 和 `bgsave`

   1. `SAVE`:在主程序中执行会阻塞当前 Redis 服务器，直到持久化工作完成 save 。执行 save 命令期间，Redis 不能处理其他命令，<font color=red>线上禁止使用</font>。<br><img src="./assets/image-20250227214123476.png" alt="image-20250227214123476" style="zoom:67%;" />

   2. `BGSAVE`(默认):Redis 会在后台异步进行快照操作，不阻塞快照同时还可以响应客户端请求，该触发方式会 fork 一个子进程由子进程复制持久化过程。Redis 会使用 bgsave 对当前内存中的所有数据做快照这个操作是子进程在后台完成的，这就允许主进程同时可以修改数据。<br><img src="./assets/image-20250227214801418.png" alt="image-20250227214801418" style="zoom:67%;" />

      > - 在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会 exec 系统调用，出于效率考虑，尽量避免膨胀。
      > - RDB 最大限度地提高了 Redis 的性能，因为 Redis 父进程为了持久化而需要做的唯一工作就是派生一个将完成所有其余工作的子进程。父进程永远不会执行磁盘1/O或类似操作。

   3. `LASTSAVE`可以通过命令获取最后一次成功执行快照的时间,是一个时间戳。

      > 可以使用 linux 命令`date -d@<time>`转换为具体时间。

      ```bash
      127.0.0.1:6379> bgsave
      Background saving started
      127.0.0.1:6379> lastsave
      (integer) 1740663998
      127.0.0.1:6379> quit
      
      $ date -d @1740663998
      Thu Feb 27 09:46:38 PM CST 2025
      ```

6. 触发 rdb 快照的情况:

   1. 配置文件中默认的快照配置。
   2. 手动 `save` 或者 `bgsave `命令。
   3. 执行 `flushall` 或者 `flushdb` 命令也会产生 rdb 文件，但里面是空的，无意义。
   4. 执行 `shutdown` 且未设置开启 `AOF`持久化( aof 开启时 Redis 会优先使用 AOF 文件进行持久化，而不会生成 RDB 文件)。
   5. 主从复制时，主节点自动触发。

7. 如何检查修复 rdb 文件:`redis-check-rdb /redis/bak/dump6379.rdb`

   ```bash
   $ which redis-check-rdb
   /usr/local/bin/redis-check-rdb
   
   
   $ redis-check-rdb /redis/bak/dump6379.rdb
   [offset 0] Checking RDB file /redis/bak/dump6379.rdb
   [offset 26] AUX FIELD redis-ver = '7.4.2'
   [offset 40] AUX FIELD redis-bits = '64'
   [offset 52] AUX FIELD ctime = '1740653089'
   [offset 67] AUX FIELD used-mem = '1142896'
   [offset 79] AUX FIELD aof-base = '0'
   [offset 81] Selecting DB ID 0
   [offset 107] Checksum OK
   [offset 107] \o/ RDB looks OK! \o/
   [info] 2 keys read
   [info] 0 expires
   [info] 0 already expired
   [info] 0 subexpires
   ```

   > 什么情况下 rdb 文件会损坏？
   >
   > - 使用网络存储或云盘时，传输过程中发生数据包丢失或校验错误。
   > - 在生成 RDB(`BGSAVE`)过程中，Redis 主进程或 fork 出的子进程意外崩溃，导致 RDB 文件不完整。
   > - 磁盘坏道、存储介质损坏、电源故障等物理问题，导致 RDB 文件写入或读取时发生数据丢失或损坏。

8. 如何从 rdb 文件恢复数据:关闭 Redis 实例，删除生成的 rdb 文件，将要恢复的 rdb 文件复制到配置的 rdb 文件目录，重启 Redis，此时 Redis 会自动读取 rdb 文件，恢复数据。<font color=red>注意不可以把备份文件 dump.rdb 和生产 redis 服务器放在同一台机器，必须分开各自存储，以防生产机物理损坏后备份文件也挂了。</font>

9. 如何禁用 RDB机制:修改配置文件 redis.conf 为`save ""`,当然也可以采用动态的方式设置:`redis-cli -a xxxx config set save ""`。

10. RDB配置优化:

    1. 控制触发 RDB 快照的条件，格式为 `save <seconds> <keys-changed>`。高数据安全性时可以增加保存频率，但是需接受更高性能开销;高性能优先时可以减少保存频率或禁用 RDB(可改用 AOF)。
    2. `dbfilename`设置 rdb 文件名称，建议`dump`+`port`命名。
    3. `dir`设置 rdb 文件存储位置。
    4. `stop-writes-on-bgsave-error`当 RDB 持久化失败时，是否禁止写入操作，默认 `yes`，一般保持默认即可。
    5. `rdbcompression`是否压缩 RDB 文件，默认 `yes`(LZF 压缩)。一般保持默认即可，若磁盘空间充足且 CPU 资源紧张，可关闭压缩以降低延迟。
    6. `rdbchecksum`是否在 RDB 文件末尾添加 CRC64 校验和，默认 `yes`。建议保持默认 `yes` 以确保数据完整性，除非对性能极度敏感。
    7. `rdb-del-sync-files`在没有持久性的情况下删除复制中使用的 RDB 文件。默认情况下no，此选项是禁用的。

11. RDB 的优势和缺点:

    1. 优势:
       - 适合大规模的数据恢复
       - 按照业务定时备份
       - 对数据完整性和一致性要求不高
       - RDB文件在内存中的加载速度要比AOF快得多
    2. 缺点:
       - 在一定间隔时间做一次备份，所以如果 redis 意外宕机的话，就会丢失从当前至最近一次快照期间的数据，快快照之间的数据会丢失
       - 内存数据的全量同步，如果数据量太大会导致 I/O 严重影响服务器性能
       - RDB 依赖于主进程的 fork ，在更大的数据集中，这可能会导致服务请求的瞬间延迟。
       - fork 的时候内存中的数据被克隆了一份，大致 2 倍的膨胀性，需要考虑。

    <br><img src="./assets/image-20250227201447042.png" alt="image-20250227201447042" style="zoom:60%;" />

    





##### RDB报错

1. `MISCONF Redis is configured to save RDB snapshots, but it's currently unable to persist to disk.`

   1. 调整内核参数(允许内存超额分配):

      ```bash
      # 临时生效
      sudo sysctl vm.overcommit_memory=1
      
      # 永久生效（写入配置文件）
      echo "vm.overcommit_memory=1" >> /etc/sysctl.conf
      sudo sysctl -p
      ```

   2. 修复目录权限:

      ```bash
      # 查看 redis启动用户
      ps -eo pid,user,comm | grep redis-server
      # 775 fish     redis-server
          
      # 修改目录所有者为Redis用户
      sudo chown -R <user>:<group> /redis/bak
      
      # 确保目录可写
      sudo chmod -R 755 /redis/bak
      ```

      > 关于配置文件权限问题参照[1.简介与安装.md](./1.简介与安装.md)的 配置文件权限问题 相关笔记。

2. 其他常见错误:

   |                         **日志内容**                         |               **原因**                |
   | :----------------------------------------------------------: | :-----------------------------------: |
   |   `Can't save in background: fork: Cannot allocate memory`   |  内存不足，无法fork子进程生成RDB快照  |
   |     `Failed opening .rdb for saving: Permission denied`      |        Redis进程无目录写入权限        |
   | `Write error writing DB file on disk: No space left on device` |             磁盘空间不足              |
   |              `Bad file format reading RDB file`              | RDB文件损坏（需修复或删除后重新生成） |







##### AOF

1. AOF 持久化记录服务器接收到的每个写操作。这些操作可以在服务器启动时再次回放，重建原始数据集。命令使用与 Redis 协议相同的格式进行记录。

2. 以日志的形式来记录每个写操作，<font color=red>将 Redis 执行过的所有写指令记录下来(读操作不记录)</font>，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，Redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

3. AOF 持久化工作流程:<br><img src="./assets/image-20250228161554382.png" alt="image-20250228161554382" style="zoom:67%;" />

   |      |                                                              |
   | ---- | ------------------------------------------------------------ |
   | 1    | Client作为命令的来源，会有多个源头以及源源不断的请求命令。   |
   | 2    | 在这些命令到达Redis Server 以后并不是直接写入AOF文件，会将其这些命令先放入AOF缓存中进行保存。这里的AOF缓冲区实际上是内存中的一片区域，存在的目的是当这些命令达到一定量以后再写入磁盘，避免频繁的磁盘IO操作。 |
   | 3    | AOF缓冲会根据AOF缓冲区**同步文件的三种写回策略**将命令写入磁盘上的AOF文件。 |
   | 4    | 随着写入AOF内容的增加为避免文件膨胀，会根据规则进行命令的合并(又称**AOF重写**)，从而起到AOF文件压缩的目的。 |
   | 5    | 当Redis Server 服务器重启的时候会从AOF文件载入数据。         |

4. 配置:

   1. 默认情况下，Redis 是没有开启 AOF 的。开启AOF功能需要设置配置：`appendonly yes`

   2. 三种写回策略:在配置文件中配置`appendsync <xx>`

      - always:同步写回，每个写命令执行完立刻同步地将日志写回磁盘
      - everysec(默认):每秒写回，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔 1 秒把缓冲区中的内容写入磁盘
      - no操作系统控制的写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘

      <br><img src="./assets/image-20250228161922420.png" alt="image-20250228161922420" style="zoom: 50%;" />

   3. aof 文件保存路径:

      1. redis 6:AOF 保存文件的位置和RDB保存文件的位置一样，都是通过 redis.conf 配置文件的 dir 配置。
      2. redis 7:可以通过`appenddirname <dir>` 设置路径，最终 aof 文件保存路径位置为` dir`+`appenddirname`这两个配置的组合。

   4. aof 文件名称:还是建议和 Redis 实例的端口号相关。

      1. redis 6:通过`appendfilename <file_name>`指定文件名称，只会生成一个文件。

      2. redis 7:通过`appendfilename <file_name>`指定文件名称,会生成三个文件。<br><img src="./assets/image-20250228163042596.png" alt="image-20250228163042596" style="zoom:85%;" />

         > 官方文档描述: 自 Redis 7.0.0 以来，Redis 使用多部分 AOF 机制。也就是说，原始的单个 AOF  文件被分割成基础文件(最多一个)和增量文件(可能有多个)。基础文件代表 AOF 重写时现有数据的初始(RDB 或 AOF  格式)快照。增量文件包含自上次创建基础 AOF 文件以来的增量更改。所有这些文件都放在一个单独的目录中，并由清单文件跟踪。<font color=blue>实际上还有 history 类型的 aof 文件，但是会被 redis 自动清理。 </font>

5. <font color=red>aof 重写机制</font>:

   1. 由于 AOF 持久化是 Redis 不断将写命令记录到 AOF 文件中，随着Redis不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。为了解决这个问题，Redis新增了重写机制，当AOF文件的大小超过所设定的峰值时，Redis 就会自动启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集或者可以手动使用命令 `bgrewriteaof` 来重新。

   2. 一句话来说就是:启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。

   3. 具体情景:多次对同一个 String 类型的 key 进行更改，在 aof 文件中会完整记录这个过程，实际上这是没有必要的，只需要记录最后一次更改即可，而重写机制就可以实现将多次操作重写为一次等效操作。

   4. 配置重写条件:同时满足条件才会触发。

      1. `auto-aof-rewrite-percentage`设置文件基于上次重写后的增长百分比。

      2. `auto-aof-rewrite-min-size`设置AOF重写的最小触发阈值。

      3. 默认配置如下:当文件达到 64 mb 及以上且在上次重写后文件的基础上大小增长 1 倍，就触发重写。

         ```bash
         auto-aof-rewrite-percentage 50
         auto-aof-rewrite-min-size 64mb
         ```

   5. 触发机制:

      1. 自动触发:根据配置文件条件触发，默认当文件达到 64 mb 及以上且在上次重写后文件的基础上大小增长 1 倍时触发重写。
      2. 手动触发:客户端向服务器发送 `bgrewriteaof`命令。

   6. aof 重写原理:

      1. 在重写开始前，redis 会创建一个重写子进程，这个子进程会读取现有的 aof 文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。
      2. 与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区(重写缓冲区)中，一边继续写入到原有的 aof 文件中(通过原 aof 缓冲区)，这样做是保证原有的 aof 文件的可用性，避免在重写过程中出现意外。
      3. 当重写子进程完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存(重写缓冲区)中缓存的写指令追加到新 aof 文件中。
      4. 当追加结束后，redis 就会用新 aof 文件来代替旧 aof 文件，之后再有新的写指令，就都会追加到新的 aof 文件中
      5. 重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似

6. 不妨具体操作一下，开启 aof 持久化，设置文件路径和文件名称(可以关闭 rdb，避免影响):

   ```bash
   dir "/redis/bak"
   appendonly yes
   appendfilename "appendonly6379.aof"
   appenddirname "appendonlydir"
   auto-aof-rewrite-percentage 100
   auto-aof-rewrite-min-size 1k
   
   # 关闭混合模式(后续会提)
   aof-use-rdb-preamble no
   ```

   配置完成后重启数据库，会发现 aof 文件已经自动生成：

   ```bash
   $ ll
   total 8
   drwxr-xr-x 2 fish fish 4096 Feb 28 17:10 .
   drwxr-xr-x 3 fish fish 4096 Feb 28 17:10 ..
   
   $ ll
   total 12
   drwxr-xr-x 2 fish fish 4096 Feb 28 17:10 .
   drwxr-xr-x 3 fish fish 4096 Feb 28 17:10 ..
   -rw-r--r-- 1 fish fish    0 Feb 28 17:10 appendonly6379.aof.1.base.aof
   -rw-r--r-- 1 fish fish    0 Feb 28 17:10 appendonly6379.aof.1.incr.aof
   -rw-r--r-- 1 fish fish   96 Feb 28 17:10 appendonly6379.aof.manifest
   ```

   当我们向数据库中写入时，发现文件夹中多出一下数据

   ```bash
   127.0.0.1:6379> set v1 1111111111111
   OK
   127.0.0.1:6379> set v1 1111111111112
   OK
   127.0.0.1:6379> set v1 1111111111113
   OK
   127.0.0.1:6379> set v1 1111111111114
   OK
   ```

   此时在回头看 aof 文件，会发现 incr.aof 文件变大:

   ```bash
   $ ll
   total 16
   drwxr-xr-x 2 fish fish 4096 Feb 28 17:10 .
   drwxr-xr-x 3 fish fish 4096 Feb 28 17:11 ..
   -rw-r--r-- 1 fish fish    0 Feb 28 17:10 appendonly6379.aof.1.base.aof
   -rw-r--r-- 1 fish fish  187 Feb 28 17:11 appendonly6379.aof.1.incr.aof
   -rw-r--r-- 1 fish fish   96 Feb 28 17:10 appendonly6379.aof.manifest
   ```

   我们不妨具体看一下 incr.aof 文件的内容:会发现其实就是我们执行的命令:<br><img src="./assets/image-20250228171749293.png" alt="image-20250228171749293" style="zoom:67%;" />

   接下来我们继续修改 v1 的值，触发重写机制,后发现 aof 文件发生变化:

   ```bash
   $ ll
   total 16
   drwxr-xr-x 2 fish fish 4096 Feb 28 17:21 .
   drwxr-xr-x 3 fish fish 4096 Feb 28 17:21 ..
   -rw-r--r-- 1 fish fish   62 Feb 28 17:21 appendonly6379.aof.2.base.aof
   -rw-r--r-- 1 fish fish    0 Feb 28 17:21 appendonly6379.aof.2.incr.aof
   -rw-r--r-- 1 fish fish   96 Feb 28 17:21 appendonly6379.aof.manifest
   ```

   此时发生重写，内容存储到 appendonly6379.aof.2.base.aof 中，appendonly6379.aof.2.incr.aof 将保存基于appendonly6379.aof.2.base.aof 的命令。此时不妨查看一下 appendonly6379.aof.2.base.aof:<br><img src="./assets/image-20250228172306968.png" alt="image-20250228172306968" style="zoom:80%;" />

7. aof 文件内容:其实通过上面操作，大致知道 aof 文件中保存我们写入操作执行的代码。<font color=red>开启 aof 后，若是我们不小心执行 flushdb 操作后，其实可以关闭 Redis 后在 aof 文件中删除对应操作的记录，然后重新启动 redis 即可，然后Redis 会读取 aof 文件恢复数据。</font>于是就存在一个好笑的操作，我们可以在 aof 文件中，手动写入 flushdb 操作，在下次启动  Redis 的时候会自动执行 flushdb ，简称代码下毒事件，若是不小心又触发重写机制，那更是完蛋。<br><img src="./assets/image-20250228173310056.png" alt="image-20250228173310056" style="zoom:67%;" />

8. aof 文件修复:`redis-check-aof --fix <file>`进行修复。

9. aof 配置优化:<br><img src="./assets/image-20250228165733283.png" alt="image-20250228165733283" style="zoom:67%;" />

10. aof 优缺点:

    1. 优势:更好的保护数据不丢失、性能高、可做紧急恢复。

    2. 劣势:相同数据集的数据而言 aof 文件要远大于 rdb 文件，恢复速度慢于 rdb 。aof 运行效率要慢于 rdb ，每秒同步策略效率较好，不同步效率和 rdb 相同。

       <br><img src="./assets/image-20250228165755206.png" alt="image-20250228165755206" style="zoom:67%;" />

    

 



##### 混合持久化

1. redi 支持同时开启 aof 和 rdb。在这种情况下,当 redis 重启的时候会优先载入 aof 文件来恢复原始的数据，因为在通常情况下 aof 文件保存的数据集要比 rdb文件保存的数据集要完整,rdb 的数据不实时，同时使用两者时服务器重启也只会找 aof 文件。<br><img src="./assets/image-20250228174915923.png" alt="image-20250228174915923" style="zoom:67%;" />
2. 诚如上面所说那要不要只使用AOF呢？建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），留着 RDB 作为一个万一的手段。
3. 但是在实际生产中还是推荐使用混合模式，结合了RDB和AOF的优点，既能快速加载又能避免丢失过多的数据。
   1. 开启方式:配置文件中设置 `aof-use-rdb-preamble` 的值为 yes。<font color=red>前提是 RDB 和 AOF 均要开启！！！</font>
   2. RDB + AOF 的混合方式时，RDB 镜像做全量持久化，AOF 做增量持久化:先使用 RDB 进行快照存储，然后使用 AOF 持久化记录所有的写操作，当重写策略满足或手动触发重写的时候，将最新的数据存储为新的 RDB 记录。这样的话，重启服务的时候会从 RDB 和 AOF 两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。简单来说：混合持久化方式产生的文件一部分是RDB格式，一部分是AOF格式。

| **模式**         | **数据安全性** | **恢复速度**  | **文件大小** | **性能开销** | **适用场景**               |
| ---------------- | -------------- | ------------- | ------------ | ------------ | -------------------------- |
| 纯 RDB           | 低             | 快            | 小           | 低           | 允许数据丢失，快速恢复     |
| 纯 AOF           | 高             | 慢            | 大           | 中           | 数据完整性优先             |
| AOF+RDB 同时开启 | 高             | 慢（优先AOF） | 大 + 小      | 高           | 双重保障，灵活性高         |
| AOF+RDB 混合模式 | 高             | 较快          | 中等         | 中           | 生产环境推荐（Redis 4.0+） |





##### 纯缓存

当我们仅仅将 Redis 作为缓存数据库使用时(纯缓存模式)，数据安全就没有那么重要，此时为了提高数据库的性能，我们需要关闭 RDB 和 AOF缓存：

- 关闭 RDB : 配置文件中设置`save ""`。
- 关闭 AOF :配置文件中配置`appendonly no`。





#### 事务





#### 管道







#### 发布订阅





