### ①基本切片
#### a.slice切片
> - `slice(start, end, step)`：从`start`到`end`，以`step`为步长切片，返回一个`slice`切片对象。
> - 通过将`start`，`stop`和`step`参数提供给内置的`slice`函数来构造一个`slice`对象。 此slice对象可以传递给数组用于提取数组切片。
> - `[start:end:step]`的本质就是`[slice(start, end, step)]`。
> - numpy提供了`np.s_`可以很容易产生`slice`对象。
> - 更多切片内容参考：[数据类型-⑧序列](https://www.yuque.com/yxlumengyu/lf5ery/bzz0uo)

```python
import numpy as np
s = np.s_[..., 0:2]
a = np.array([[1, 2, 3], [4, 5, 6]], dtype='i1')
b = [s]
```
#### b.数组切片
> - ndarray对象的内容可以通过索引或切片来访问和修改，与Python中list的切片操作一样。 
> - 数组切片返回的是原始数组视图(如果做任何修改，原始都会跟着更改)。如果不想更改原始数组，我们需要进行显式的复制，从而得到它的副本(`.copy()`)。
> - 别忘了负数索引，python与其他语言不同，存在负数索引，可以有很多骚...额...方便的操作。

> 1. 一维数组可以直接采用`[start:end:step]`来实现切片功能。
>    1. `[a]`：获得索引`a`处元素。
>    2. `[a:b]`：获得`[a, b)`处元素。
>    3. `[:b]`：获得索引`b`前面位置元素。
>    4. `[a:]`：获取索引`a`后面位置元素。
>    5. `[a::c]`：以`c`为步长执行`[a:]`。
>    6. `[:b:c]`：以`c`为步长执行`[:b]`。

```python
import numpy as np

a = np.array([1, 2, 3, 4, 5, 6])
b = a[::2]
b[0] = 9
print(a)
# [9 2 3 4 5 6]  a更改
```
> 2. 对于多维数组可以采用两种方式：
>    1. 连续切片：`[start:end:step][start:end:step]...`，其实相当于对切片结果切片。
>    2. 逗号分隔：`[start:end:step, start:end:step]`，不同维度的切片用`,`隔开。

```python
import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
b = a[::2][::3]
c = a[::2, ::3]
# b,c修改,a也会修改

s1 = slice(0, 3, 2)
s2 = slice(0, 3, 3)
d = a[s1, s2]
```
> 3. 切片还可以使用省略号`...` 。省略号(Ellipsis，字面值)扩展为选择元组索引所有维度所需的多个` :`，例如`a[...]`直接返回整个数组。
> 4. 之前误以为`...`代表省略某一维度，结果导致很多内容解释不通。

```python
import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
b = a[...]  # 相当于[:, :]
# [[1 2 3]
#  [4 5 6]
#  [7 8 9]]

c = a[..., 0]  # 相当于a[:, 0] 
# [1 4 7]  # 这里的0其实是[0],属于高级索引

d = a[...][0]
# [1 2 3]  # 这里的0其实是[0],属于高级索引
```
```python
# 补充强调：
import numpy as np

base = np.array([[[1], [4], [7]], [[2], [5], [7]]])
ans = base[..., 0]
"""
相当于ans = base[:, :, 0],...代表多个:
[[1 4 7]
 [2 5 7]]
"""
```
> 这里要说明一下：
>    1. `c = a[..., 0]`相当于行全选，列只选为0。执行后返回给c。所以结果是`[1 4 7]`。(一次切片)
>    2. `d = a[...][0]`相当于先执行`a[...]`返回整个a的视图，再执行`[0]`取第一行。所以结果为`[1 2 3]`。(两次切片)


---

### ②高级索引
> 1. 当 NumPy数组的选择对象obj是非元组序列对象(list、但set、dict好像不行)、ndarray(数据类型为integer或bool)或至少有一个序列对象或ndarray(数据类型为integer或bool)的元组时，会触发高级索引。NumPy有两种类型的高级索引：整型和布尔型。
> 2. 高级索引总是返回数据的副本，与基本索引切片返回视图的不同。有高级索引参与的，一般也均返回副本。

#### a.整数索引
> - 整数索引允许根据数组中的任意项的N维索引来选择它们。每个整数数组(或序列对象)表示该维度中的多个索引。数组(序列对象)中允许出现负值，并且与处理单个索引或切片时一样。
> - `x[(a, b, c),]`与`x[(a, b, c)]`有根本不同。后者相当于`x[a, b, c]`，它将触发基本选择，返回对应视图。而前者将触发高级索引，返回对应副本。
> - `x[[1, 2, 3]]`将触发高级索引，而由于不推荐的数字兼容性，`x[[1, 2, slice(None)]]`将触发基本切片(不知道为啥我执行报错，待验证)。
> - 单个整形作为索引，也是高级索引，返回对应副本。

```python
# 整数索引
import numpy as np

base = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

a = base[[0, -1]]
# [[1 2 3]
#  [7 8 9]]
# [0, -1]表示行维度的0、-1索引。与其他无关

a[0][0] = 9  # 对原数组base无影响，高级索引返回的是副本。
```
```python
# 单个int索引
import numpy as np

base = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])  # ()

a = base[1]
a[0] = 9  # 高级索引，返回副本
```
```python
# 易错
import numpy as np

base = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
a = base[(0, 2)]
# 3,相当于base[0,2],估计括号被当成运算符了(基本索引)

b = base[(0, 2), ]
# [[1 2 3]
#  [7 8 9]]
# 触发高级索引
# b为副本,不影响a
```
> 1. 整数索引允许根据数组中的任意项的N维索引来选择它们。每个整数数组表示该维度中的多个索引。简单来说就是可以用多个整数数组(序列)作为索引。但是高级索引始终作为一个索引进行广播和迭代。
> 2. 当我们使用两个list(其他一样)作为一个高级索引，`array[[a, b, c], [d, e, f]]`实际上选择的是`(a, d)、(b, e)、(c, f)`
> 3. `a[list_a, list_b,...]`当索引(`a,b,...`)形状不一致就会触发广播机制，广播后的形状作为返回副本基本参考形状(不是最终情况，因为返回可能不止一条数据，具体分析，参考示例)，无法广播就会报错。

```python
import numpy as np

base = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])  # ()

a = base[[0, 1], [0, 1, -1]]  # (2,)和(3,)无法广播报错

b = base[[[1, -1], [0, -1]]]
# [[[4 5 6] [7 8 9]]
#  [[1 2 3] [7 8 9]]]
# 感觉一个数组(序列)做索引,就是把数字替换对应结果

c = base[[[1, -1], [0, -1]], [0, 1]]
# [[4 8]
#  [1 8]]
# 先广播(通分?),化成同型。然后把对应的结果替换每组索引坐标。
# [[1 -1]   --->  [[0 1]  --->  [[(1,0) (-1,1)]   --->  [[4 8]
#  [0 -1]]  --->   [0 1]] --->   [(0,0) (-1,1)]]  --->   [1 8]]
```

#### b.布尔索引
> 1. 用作索引的布尔数组的处理方式与索引数组完全不同。布尔数组的形状必须与要索引的数组对应维度尺寸相同。
> 2. 单个bool型也可以作为索引，但多条件比较时注意使用括号，例`a[(a < 9) & (a > 6)]`。个人感觉就是把被索引数组视为一维数组，将各元素按行主序迭代判断。
> 3. 与整数索引数组的情况不同，在布尔情况下，结果是一个一维数组，其中包含索引数组中与布尔数组中所有真实元素对应的所有元素，并以行主顺序返回。

```python
# bool数组
import numpy as np

base = np.array([[1, 2, 3], [4, 5, 6]])
chs_1 = [[True, False, True], [True, True, False]]
ans_1 = base[chs_1]
# [1 3 4 5]  # 行主序返回亿一维数组

chs_2 = np.array([[True, False, True], [True, True, False]], dtype=np.bool_)
ans_2 = base[chs_2]
# [1 3 4 5]  # 行主序返回亿一维数组
```
```python
import numpy as np

base = np.array([1, 2, 3, 4, 5])
ans_1 = base[base >= 2]
ans_2 = base[(base > 2) & (base < 5)]  # 注意括号


def judge(x) -> bool:
	return x > 5  # md,传进来的是整个数组(大坑)


base_2 = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])
ans_3 = base_2[judge(base_2)]
# [ 6  7  8  9 10]
```

#### c.混合使用
> 1. 高级索引可以与切片结合使用。但是实际上，切片和索引数组操作仍是独立的。
> 2. 一个高级索引可以替换一个切片，结果数组将是相同的。但是，它是一个副本。
> 3. 理解多个高级索引组合的最简单方法可能是根据生成的形状进行思考。 索引操作有两个部分，由基本索引(不包括整数)定义的子空间和高级索引部分定义的子空间。 需要区分两种索引组合的情况：
>    1. 高级索引由切片、省略号(Ellipsis)或newaxis分隔。例如`x[arr1, :, arr2]`。
>    2. 高级指数彼此相邻。例如`x[..., arr1, arr2, :]`。
>    3. 整数属于高级索引。
>    4. 有高级索引参与，结果一般都为副本，而非视图。
>    5. 这个需要一步步分析。

```python
import numpy as np

base = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

ans_1 = base[[0, 1], -1:-3:-1]
# 二者操作其实是分开的,高级索引限定1、2行,切片获取1、2列

ans_2 = base[:2, -1:-3:-1]
# 结果与ans_1一致。
# 但是ans_1有高级索引,得到的是副本。而ans_2只有切片，得到的是视图。
```
```python
# 巨坑
import numpy as np

base = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
chs = [True, False, True]
ans_1 = base[chs, 0:2]
# bool索引限制1、3行,切片获取1、2列

ans_2 = base[base > 5, ::-1]
ans_3 = np.array([1, 2, 3])[chs, ::-1]
"""
这两个报错,why?
对于ans_2：我们对数组判断是对整个数组所有元素判断,已经对所有元素筛选过,::-1就没有执行对象了。对于ans_3：同样的,chs已经筛选所有,::-1无法执行。而对于ans_1：chs只对行进行筛选,0:2对列切片。
"""
```
```python
import numpy as np

base = np.array([[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]]])
chs = [True, False]
ans_1 = base[chs, ::-1, [1, 2]]
print(ans_1)
"""
, ::-1, [1, 2]
通过chs得到：
[[[1 2 3] [4 5 6] [7 8 9]]]
通过::-1得到:
[[[7 8 9] [4 5 6] [1 2 3]]]
通过[1, 2]得到:
[[8 5 2] [9 6 3]]
这里可以认为[8 5 2]、[9 6 3]这两列替换了原来[1, 2]中的索引值。
"""
```
```python
import numpy as np

base = np.array([[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]]])
ans = base[1, [1, 2], ...]
"""
首先1与[1, 2]先要广播,类似于[(1,1),(1,2)],
从而得到:
[[4 5 6] [7 8 9]]
然后...全选。
"""
```

#### d.广播机制
> 1. NumPy操作通常是按一一对应元素对数组执行的。
> 2. 广播描述的是NumPy如何计算不同形状的数组之间的运算。如果是较大的矩阵和较小的矩阵进行运算的话，较小的矩阵就会被广播，从而保证运算的正确进行。
> 3. 广播的原则是，如果两个数组的后缘维度(从末尾开始算起的维度)的轴长相符或其中一方的长度为1(也可以缺失)，则认为它们是广播兼容的，广播会在缺失和(或)长度为1的轴上进行。
> 4. 将两个数组的维度大小右对齐，然后比较对应维度上的数值， 如果数值相等或其中有一个为1或者为空，则能进行广播运算， 输出的维度大小为维度大的数值。否则不能进行数组运算。 
> 5. 若不满足这些条件，将引发 `ValueError: operands could not be broadcast together`(操作数无法一起广播异常)。
> 6. 个人觉得广播形式上类似于自我复制，从低维度到高维度，运用已处理好的低维度数据填补高维度数据，从而保证计算的正常进行。
> 
![image.png](https://cdn.nlark.com/yuque/0/2023/png/22979213/1673695508197-8443357a-8b28-4e5b-8ca2-f16f3a05be0a.png#averageHue=%23fbf7f2&clientId=ua93c3498-917d-4&from=paste&height=336&id=ubd608fc1&name=image.png&originHeight=420&originWidth=407&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42142&status=done&style=none&taskId=u77533ec5-c4dd-46a5-9b21-0db1e1c6339&title=&width=325.6)

```python
import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])  # (3,3)
b = np.array([1, 1])  # (2,)
tem = a + b  # 无法广播,报错


c = np.array([
	[[1, 2, 3]],
	[[1, 2, 3]]
])  # (2,1,3)

d = np.array([
	[4, 5, 6]
])  # (1,3)

ans = c + d  # (2,1,3)

# [[[1 2 3]]    +   [[[4 5 6]]
#  [[1 2 3]]]   +    [[4 5 6]]]
```
```
A				(4维array)  8 1 6 5
B   		(3维array)    7 1 5
result	(4维array)  8 7 6 5

分别满足条件(缺失、为1、为1、相等),结果数组维度取二者最大值。

A				(4维array)  8 1 6 5
B   		(2维array)      5 5
result	(error)  

6、5组合不满足任何一种情况,无法广播,报错。
```

### <补充>
#### a.副本\视图
> 待补

